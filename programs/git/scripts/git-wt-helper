#!/usr/bin/env bash

set -o nounset
set -o errexit
set -o pipefail

show_help() {
  cat <<'EOF'
git-wt-helper - Git worktree helper

Manages worktrees with automatic reuse of merged branches.

Supports both bare repos (worktrees in <repo>/wt-xxx/) and
non-bare repos (worktrees in <repo>/.worktrees/wt-xxx/).

Usage:
  git wt <branch>     Create new branch or switch to existing branch's worktree
  git wt -n <branch>  Always create a new worktree (don't reuse existing ones)
  git wt              Select worktree with fzf
  git wt -b           Back to repo root (handled by shell wrapper)

Options:
  -n                  Force creation of a new worktree
  -h, --help          Show this help and exit

Behavior:
  - Worktrees are stored as wt-001, wt-002, ...
  - When creating a new branch, reuses worktrees whose branches are merged
  - Detects both merge commits and squash merges
EOF
}

die() {
  printf '%s\n' "$*" >&2
  exit 1
}

#######################################
# Shared utilities
#######################################

# Get the default branch name (e.g., main, master)
get_default_branch() {
  local remote_head
  remote_head=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null) && {
    echo "${remote_head#refs/remotes/origin/}"
    return
  }
  # Fallback: try common names
  for branch in main master; do
    if git show-ref --verify --quiet "refs/heads/$branch"; then
      echo "$branch"
      return
    fi
  done
  die "Cannot determine default branch"
}

# Check if worktree has uncommitted changes
is_worktree_dirty() {
  local worktree_path=$1
  [[ -n $(git -C "$worktree_path" status --porcelain 2>/dev/null) ]]
}

# Check if a branch is merged into default branch (merge commit or squash)
is_merged() {
  local branch=$1
  local default_branch=$2

  # Check merge commit
  if git merge-base --is-ancestor "$branch" "$default_branch" 2>/dev/null; then
    return 0
  fi

  # Check squash merge: compare tree state
  local merge_base tree_commit cherry_result
  merge_base=$(git merge-base "$default_branch" "$branch" 2>/dev/null) || return 1
  tree_commit=$(git commit-tree "$(git rev-parse "$branch^{tree}")" -p "$merge_base" -m _) || return 1
  cherry_result=$(git cherry "$default_branch" "$tree_commit" 2>/dev/null) || return 1

  [[ $cherry_result == -* ]]
}

# Check if branch exists locally or remotely
branch_exists() {
  local branch=$1
  git show-ref --verify --quiet "refs/heads/$branch" ||
    git show-ref --verify --quiet "refs/remotes/origin/$branch"
}

#######################################
# Bare repo functions
#######################################

# List all worktrees (excluding the bare entry)
# Output format: <path>:<branch>
bare_list_worktrees() {
  git worktree list --porcelain | awk '
    /^worktree / { path = substr($0, 10) }
    /^branch /   { branch = substr($0, 8); sub("refs/heads/", "", branch) }
    /^bare$/     { is_bare = 1 }
    /^$/ {
      if (!is_bare && path != "" && branch != "") {
        print path ":" branch
      }
      path = ""; branch = ""; is_bare = 0
    }
    END {
      if (!is_bare && path != "" && branch != "") {
        print path ":" branch
      }
    }
  '
}

# Find an unused (merged) worktree and return its path
bare_find_unused_worktree() {
  local default_branch=$1
  local worktree_path branch

  while IFS=: read -r worktree_path branch; do
    [[ -z $worktree_path ]] && continue
    is_worktree_dirty "$worktree_path" && continue
    if is_merged "$branch" "$default_branch"; then
      echo "$worktree_path"
      return 0
    fi
  done < <(bare_list_worktrees)

  return 1
}

# Create a new worktree with the next available number
bare_create_new_worktree() {
  local repo_root=$1
  local branch=$2
  local default_branch=$3
  local num=1 new_path

  while [[ -d "$repo_root/wt-$(printf '%03d' $num)" ]]; do
    ((num++))
  done

  new_path="$repo_root/wt-$(printf '%03d' $num)"
  git worktree add -b "$branch" "$new_path" "$default_branch" >&2
  echo "$new_path"
}

# Prepare a worktree for a new branch (reuse or create)
bare_prepare_worktree() {
  local branch=$1
  local default_branch repo_root unused_worktree

  default_branch=$(get_default_branch)
  repo_root=$(git rev-parse --git-common-dir)

  if [[ $FORCE_NEW == false ]] && unused_worktree=$(bare_find_unused_worktree "$default_branch"); then
    (
      cd "$unused_worktree"
      git fetch -q origin "$default_branch" 2>/dev/null || true
      git checkout -q -B "$branch" "origin/$default_branch"
    ) >&2
    echo "$unused_worktree"
  else
    bare_create_new_worktree "$repo_root" "$branch" "$default_branch"
  fi
}

# Find worktree for an existing branch
bare_find_worktree_for_branch() {
  local target_branch=$1
  local worktree_path branch

  while IFS=: read -r worktree_path branch; do
    if [[ $branch == "$target_branch" ]]; then
      echo "$worktree_path"
      return 0
    fi
  done < <(bare_list_worktrees)

  return 1
}

# Select worktree with fzf, or create new branch if query doesn't match
bare_select_with_fzf() {
  local fzf_out query selected

  fzf_out=$(
    bare_list_worktrees | while IFS=: read -r path branch; do
      printf '%s\t%s  %s\n' "$path" "$(basename "$path")" "$branch"
    done | fzf --prompt='worktree> ' \
        --with-nth=2 \
        --delimiter=$'\t' \
        --preview='cd {1} && git log --oneline -10' \
        --print-query
  ) || true

  query=$(echo "$fzf_out" | sed -n '1p')
  selected=$(echo "$fzf_out" | sed -n '2p')

  if [[ -n $selected ]]; then
    echo "$selected" | cut -d$'\t' -f1
  elif [[ -n $query ]]; then
    exec "$0" "$query"
  fi
}

bare_main() {
  if (($#)); then
    local branch=$1

    # Check if branch already has a worktree
    if worktree_path=$(bare_find_worktree_for_branch "$branch"); then
      echo "$worktree_path"
      exit 0
    fi

    # Check if it's an existing branch (local or remote)
    if branch_exists "$branch"; then
      local default_branch repo_root
      default_branch=$(get_default_branch)
      repo_root=$(git rev-parse --git-common-dir)

      if [[ $FORCE_NEW == false ]] && unused_worktree=$(bare_find_unused_worktree "$default_branch"); then
        (
          cd "$unused_worktree"
          if git show-ref --verify --quiet "refs/heads/$branch"; then
            git checkout -q "$branch"
          else
            git checkout -q -b "$branch" "origin/$branch"
          fi
        ) >&2
        echo "$unused_worktree"
      else
        local num=1 new_path
        while [[ -d "$repo_root/wt-$(printf '%03d' $num)" ]]; do
          ((num++))
        done
        new_path="$repo_root/wt-$(printf '%03d' $num)"
        git worktree add "$new_path" "$branch" >&2
        echo "$new_path"
      fi
    else
      # New branch
      bare_prepare_worktree "$branch"
    fi
  else
    bare_select_with_fzf
  fi
}

#######################################
# Non-bare repo functions
#######################################

WORKTREES_DIR=".worktrees"

# Get the root directory of the main worktree
nonbare_get_main_worktree() {
  git worktree list --porcelain | head -1 | sed 's/^worktree //'
}

# Get worktrees directory path
nonbare_get_worktrees_dir() {
  local main_worktree
  main_worktree=$(nonbare_get_main_worktree)
  echo "$main_worktree/$WORKTREES_DIR"
}

# List all worktrees with their branches (excluding main worktree)
# Output format: <path>:<branch>
nonbare_list_worktrees() {
  local main_worktree
  main_worktree=$(nonbare_get_main_worktree)

  git worktree list --porcelain | awk -v main="$main_worktree" '
    /^worktree / { path = substr($0, 10) }
    /^branch /   { branch = substr($0, 8); sub("refs/heads/", "", branch) }
    /^$/ {
      if (path != main && path != "") {
        print path ":" branch
      }
      path = ""; branch = ""
    }
    END {
      if (path != main && path != "") {
        print path ":" branch
      }
    }
  '
}

# Find an unused (merged) worktree and return its path
nonbare_find_unused_worktree() {
  local default_branch=$1
  local worktree_path branch

  while IFS=: read -r worktree_path branch; do
    [[ -z $worktree_path ]] && continue
    is_worktree_dirty "$worktree_path" && continue
    if is_merged "$branch" "$default_branch"; then
      echo "$worktree_path"
      return 0
    fi
  done < <(nonbare_list_worktrees)

  return 1
}

# Create a new worktree with the next available number
nonbare_create_new_worktree() {
  local worktrees_dir=$1
  local branch=$2
  local default_branch=$3
  local num=1 new_path

  mkdir -p "$worktrees_dir"

  while [[ -d "$worktrees_dir/wt-$(printf '%03d' $num)" ]]; do
    ((num++))
  done

  new_path="$worktrees_dir/wt-$(printf '%03d' $num)"
  git worktree add -b "$branch" "$new_path" "$default_branch" >&2
  echo "$new_path"
}

# Prepare a worktree for a new branch (reuse or create)
nonbare_prepare_worktree() {
  local branch=$1
  local default_branch worktrees_dir unused_worktree

  default_branch=$(get_default_branch)
  worktrees_dir=$(nonbare_get_worktrees_dir)

  if [[ $FORCE_NEW == false ]] && unused_worktree=$(nonbare_find_unused_worktree "$default_branch"); then
    (
      cd "$unused_worktree"
      git fetch -q origin "$default_branch" 2>/dev/null || true
      git checkout -q -B "$branch" "origin/$default_branch"
    ) >&2
    echo "$unused_worktree"
  else
    nonbare_create_new_worktree "$worktrees_dir" "$branch" "$default_branch"
  fi
}

# Find worktree for an existing branch
nonbare_find_worktree_for_branch() {
  local target_branch=$1
  local worktree_path branch

  while IFS=: read -r worktree_path branch; do
    if [[ $branch == "$target_branch" ]]; then
      echo "$worktree_path"
      return 0
    fi
  done < <(nonbare_list_worktrees)

  return 1
}

# Select worktree with fzf, or create new branch if query doesn't match
nonbare_select_with_fzf() {
  local main_worktree default_branch fzf_out query selected
  main_worktree=$(nonbare_get_main_worktree)
  default_branch=$(get_default_branch)

  fzf_out=$(
    {
      # Add main worktree first (format: path<TAB>display)
      printf '%s\t%s  %s\n' "$main_worktree" "(main)" "$default_branch"
      # Add other worktrees with name
      nonbare_list_worktrees | while IFS=: read -r path branch; do
        printf '%s\t%s  %s\n' "$path" "$(basename "$path")" "$branch"
      done
    } | fzf --prompt='worktree> ' \
        --with-nth=2 \
        --delimiter=$'\t' \
        --preview='cd {1} && git log --oneline -10' \
        --print-query
  ) || true

  query=$(echo "$fzf_out" | sed -n '1p')
  selected=$(echo "$fzf_out" | sed -n '2p')

  if [[ -n $selected ]]; then
    echo "$selected" | cut -d$'\t' -f1
  elif [[ -n $query ]]; then
    exec "$0" "$query"
  fi
}

nonbare_main() {
  if (($#)); then
    local branch=$1

    # Check if branch already has a worktree
    if worktree_path=$(nonbare_find_worktree_for_branch "$branch"); then
      echo "$worktree_path"
      exit 0
    fi

    # Check if it's an existing branch (local or remote)
    if branch_exists "$branch"; then
      local worktrees_dir default_branch
      worktrees_dir=$(nonbare_get_worktrees_dir)
      default_branch=$(get_default_branch)

      if [[ $FORCE_NEW == false ]] && unused_worktree=$(nonbare_find_unused_worktree "$default_branch"); then
        (
          cd "$unused_worktree"
          if git show-ref --verify --quiet "refs/heads/$branch"; then
            git checkout -q "$branch"
          else
            git checkout -q -b "$branch" "origin/$branch"
          fi
        ) >&2
        echo "$unused_worktree"
      else
        local num=1 new_path
        mkdir -p "$worktrees_dir"
        while [[ -d "$worktrees_dir/wt-$(printf '%03d' $num)" ]]; do
          ((num++))
        done
        new_path="$worktrees_dir/wt-$(printf '%03d' $num)"
        git worktree add "$new_path" "$branch" >&2
        echo "$new_path"
      fi
    else
      # New branch
      nonbare_prepare_worktree "$branch"
    fi
  else
    nonbare_select_with_fzf
  fi
}

#######################################
# Main
#######################################

[[ ${1-} == -h || ${1-} == --help ]] && {
  show_help
  exit 0
}

# Parse options
FORCE_NEW=false
while getopts "n" opt; do
  case $opt in
    n) FORCE_NEW=true ;;
    *) die "Unknown option: -$opt" ;;
  esac
done
shift $((OPTIND - 1))

# Detect repo type and dispatch
git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null) || die "Not in a git repository"
if [[ "$(basename "$git_common_dir")" == ".git" ]]; then
  nonbare_main "$@"
else
  bare_main "$@"
fi
