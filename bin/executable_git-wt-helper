#!/usr/bin/env bash

set -o nounset
set -o errexit
set -o pipefail

WORKTREES_DIR=".worktrees"

show_help() {
  cat <<'EOF'
git-wt-helper - Git worktree helper

Manages worktrees in <repo>/.worktrees/ with automatic reuse of merged branches.

Usage:
  git wt <branch>     Create new branch or switch to existing branch's worktree
  git wt              Select worktree with fzf
  git wt -b           Back to main worktree (handled by shell wrapper)

Options:
  -h, --help          Show this help and exit

Behavior:
  - Worktrees are stored in <repo>/.worktrees/wt-001, wt-002, ...
  - When creating a new branch, reuses worktrees whose branches are merged
  - Detects both merge commits and squash merges
EOF
}

die() {
  printf '%s\n' "$*" >&2
  exit 1
}

# Get the root directory of the main worktree
get_main_worktree() {
  git worktree list --porcelain | head -1 | sed 's/^worktree //'
}

# Get the default branch name (e.g., main, master)
get_default_branch() {
  local remote_head
  remote_head=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null) && {
    echo "${remote_head#refs/remotes/origin/}"
    return
  }
  # Fallback: try common names
  for branch in main master; do
    if git show-ref --verify --quiet "refs/heads/$branch"; then
      echo "$branch"
      return
    fi
  done
  die "Cannot determine default branch"
}

# Check if a branch is merged into default branch (merge commit or squash)
is_merged() {
  local branch=$1
  local default_branch=$2

  # Check merge commit
  if git merge-base --is-ancestor "$branch" "$default_branch" 2>/dev/null; then
    return 0
  fi

  # Check squash merge: compare tree state
  local merge_base tree_commit cherry_result
  merge_base=$(git merge-base "$default_branch" "$branch" 2>/dev/null) || return 1
  tree_commit=$(git commit-tree "$(git rev-parse "$branch^{tree}")" -p "$merge_base" -m _) || return 1
  cherry_result=$(git cherry "$default_branch" "$tree_commit" 2>/dev/null) || return 1

  [[ $cherry_result == -* ]]
}

# Get worktrees directory path
get_worktrees_dir() {
  local main_worktree
  main_worktree=$(get_main_worktree)
  echo "$main_worktree/$WORKTREES_DIR"
}

# List all worktrees with their branches (excluding main worktree)
# Output format: <path>:<branch>
list_worktrees() {
  local main_worktree
  main_worktree=$(get_main_worktree)

  git worktree list --porcelain | awk -v main="$main_worktree" '
    /^worktree / { path = substr($0, 10) }
    /^branch /   { branch = substr($0, 8); sub("refs/heads/", "", branch) }
    /^$/ {
      if (path != main && path != "") {
        print path ":" branch
      }
      path = ""; branch = ""
    }
    END {
      if (path != main && path != "") {
        print path ":" branch
      }
    }
  '
}

# Find an unused (merged) worktree and return its path
find_unused_worktree() {
  local default_branch=$1
  local worktree_path branch

  while IFS=: read -r worktree_path branch; do
    [[ -z $worktree_path ]] && continue
    if is_merged "$branch" "$default_branch"; then
      echo "$worktree_path"
      return 0
    fi
  done < <(list_worktrees)

  return 1
}

# Create a new worktree with the next available number
create_new_worktree() {
  local worktrees_dir=$1
  local branch=$2
  local default_branch=$3
  local num=1 new_path

  mkdir -p "$worktrees_dir"

  # Find next available number
  while [[ -d "$worktrees_dir/wt-$(printf '%03d' $num)" ]]; do
    ((num++))
  done

  new_path="$worktrees_dir/wt-$(printf '%03d' $num)"
  git worktree add -b "$branch" "$new_path" "$default_branch" >&2
  echo "$new_path"
}

# Prepare a worktree for a new branch (reuse or create)
prepare_worktree_for_new_branch() {
  local branch=$1
  local default_branch worktrees_dir unused_worktree

  default_branch=$(get_default_branch)
  worktrees_dir=$(get_worktrees_dir)

  # Try to find and reuse an unused worktree
  if unused_worktree=$(find_unused_worktree "$default_branch"); then
    # Reset the worktree to default branch and create new branch
    (
      cd "$unused_worktree"
      git fetch -q origin "$default_branch" 2>/dev/null || true
      git checkout -q -B "$branch" "origin/$default_branch"
    ) >&2
    echo "$unused_worktree"
  else
    # Create new worktree
    create_new_worktree "$worktrees_dir" "$branch" "$default_branch"
  fi
}

# Find worktree for an existing branch
find_worktree_for_branch() {
  local target_branch=$1
  local worktree_path branch

  while IFS=: read -r worktree_path branch; do
    if [[ $branch == "$target_branch" ]]; then
      echo "$worktree_path"
      return 0
    fi
  done < <(list_worktrees)

  return 1
}

# Select worktree with fzf, or create new branch if query doesn't match
select_with_fzf() {
  local main_worktree default_branch fzf_out query selected
  main_worktree=$(get_main_worktree)
  default_branch=$(get_default_branch)

  fzf_out=$(
    {
      # Add main worktree first
      echo "$main_worktree:$default_branch (main)"
      # Add other worktrees
      list_worktrees
    } | fzf --prompt='worktree> ' \
        --with-nth=2 \
        --delimiter=':' \
        --preview='cd {1} && git log --oneline -10' \
        --no-select-1 \
        --print-query \
        --bind 'enter:replace-query+print-query'
  ) || true

  # First line is query, second line is selected item (if any)
  query=$(echo "$fzf_out" | sed -n '1p')
  selected=$(echo "$fzf_out" | sed -n '2p')

  if [[ -n $selected ]]; then
    # User selected an existing worktree
    echo "$selected" | cut -d: -f1
  elif [[ -n $query ]]; then
    # No selection but query entered - treat as new branch name
    prepare_worktree_for_new_branch "$query"
  fi
  # If both empty, user cancelled - return nothing
}

# Check if branch exists locally or remotely
branch_exists() {
  local branch=$1
  git show-ref --verify --quiet "refs/heads/$branch" ||
    git show-ref --verify --quiet "refs/remotes/origin/$branch"
}

#######################################
# Main
#######################################

[[ ${1-} == -h || ${1-} == --help ]] && {
  show_help
  exit 0
}

# Ensure we're in a git repository
git rev-parse --is-inside-work-tree &>/dev/null || die "Not in a git repository"

if (($#)); then
  branch=$1

  # Check if branch already has a worktree
  if worktree_path=$(find_worktree_for_branch "$branch"); then
    echo "$worktree_path"
    exit 0
  fi

  # Check if it's an existing branch (local or remote)
  if branch_exists "$branch"; then
    # Existing branch without worktree - create worktree for it
    worktrees_dir=$(get_worktrees_dir)
    default_branch=$(get_default_branch)

    # Try to reuse unused worktree
    if unused_worktree=$(find_unused_worktree "$default_branch"); then
      (
        cd "$unused_worktree"
        # Check out existing branch (local or remote)
        if git show-ref --verify --quiet "refs/heads/$branch"; then
          git checkout -q "$branch"
        else
          git checkout -q -b "$branch" "origin/$branch"
        fi
      ) >&2
      echo "$unused_worktree"
    else
      # Create new worktree for existing branch
      num=1
      mkdir -p "$worktrees_dir"
      while [[ -d "$worktrees_dir/wt-$(printf '%03d' $num)" ]]; do
        ((num++))
      done
      new_path="$worktrees_dir/wt-$(printf '%03d' $num)"
      git worktree add "$new_path" "$branch" >&2
      echo "$new_path"
    fi
  else
    # New branch - prepare worktree
    prepare_worktree_for_new_branch "$branch"
  fi
else
  # No arguments - select with fzf
  select_with_fzf
fi
